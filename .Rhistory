fishreg <- crwMLE(data = fish, coord = c('UTM.x', 'UTM.y'), Time.name = c("Time") , time.scale = 'secs')
fishreg <- crwPredict(object.crwFit = fishreg,
predTime = seq.POSIXt(from = min(fish$Time), to = max(fish$Time), by = '5 secs'),
return.type = 'minimal')
# Isolate predicted positions
fishpred <- fishreg[fishreg$locType == 'p', ]
# Pred data for HMM(= calculate steps and TAs)
HMMdat <- prepData(fishpred[c('Time', 'mu.x', 'mu.y')], coordNames = c('mu.x', 'mu.y'), type = 'UTM')
# Calculate dStepLength and remove when dStep approaches 0 (indicating regularization in detection gaps)
# Break arbitrarily chosen based on rounding errors
HMMdat$dStep <- HMMdat$step - lag(HMMdat$step)
HMMdat <- HMMdat[(HMMdat$dStep > 3.172941e-08) | (HMMdat$dStep < -3.172941e-08), ]
HMMdat <- drop_na(HMMdat)
rownames(HMMdat) <- NULL
# Calculate timesteps to identify where detections are removed (i.e. tracks break)
# Add in timestep for first value to run for-loop later
HMMdat$timestep <- HMMdat$Time - lag(HMMdat$Time)
HMMdat$timestep[1] <- as.difftime(5, format = '%S', units = 'secs')
# Construct trackno column and initialize with Track 1
HMMdat$track <- NA
HMMdat$track[1] <- 1
# Run for-loop to count tracks
for (n in 2:nrow(HMMdat)){
if (HMMdat$timestep[n] > HMMdat$timestep[n-1]){
HMMdat$track[n] <- HMMdat$track[n-1] + 1
}
else {
HMMdat$track[n] <- HMMdat$track[n-1]
}
}
# Redefine trackno as animal ID for rerunning of prepData
HMMdat <- HMMdat[, c("x", "y", "Time", "track")]
colnames(HMMdat) <- c("x", "y", "Time", "ID")
# Re-run prepData for newly identified tracks
HMMdat2 <- prepData(HMMdat, type='UTM')
# Calculate Straightness Index (SI)
X <- split(HMMdat2, HMMdat2$ID)
for(d in 1:length(X)) {
track <- data.frame(X[d])
colnames(track) <- c("ID", "step", "angle", "x", "y", "Time")
track$SI <- NA
for (c in 6:(nrow(track)-1)){
dX <- track$x[c] - track$x[c-5]
dY <- track$y[c] - track$y[c-5]
TDist <- sum(track$step[(c-5):c])
LDist <- sqrt(dX^2 + dY^2)
#print(LDist / TDist)
track$SI[c] <- LDist / TDist
}
print(colnames(track))
if (d == 1) {
HMMdat2 <- track
}
else {
HMMdat2 <- rbind(HMMdat2, track)
}
}
View(HMMdat2)
View(track)
View(track)
View(fishpred)
View(HMMdat)
HMMdat <- prepData(fishpred[c('Time', 'mu.x', 'mu.y')], coordNames = c('mu.x', 'mu.y'), type = 'UTM')
#plot(HMMdat, compact=T)
# Calculate dStepLength and remove when dStep approaches 0 (indicating regularization in detection gaps)
# Break arbitrarily chosen based on rounding errors
HMMdat$dStep <- HMMdat$step - lag(HMMdat$step)
HMMdat <- HMMdat[(HMMdat$dStep > 3.172941e-08) | (HMMdat$dStep < -3.172941e-08), ]
HMMdat <- drop_na(HMMdat)
rownames(HMMdat) <- NULL
# Calculate timesteps to identify where detections are removed (i.e. tracks break)
# Add in timestep for first value to run for-loop later
HMMdat$timestep <- HMMdat$Time - lag(HMMdat$Time)
HMMdat$timestep[1] <- as.difftime(5, format = '%S', units = 'secs')
# Construct trackno column and initialize with Track 1
HMMdat$track <- NA
HMMdat$track[1] <- 1
# Run for-loop to count tracks
for (n in 2:nrow(HMMdat)){
if (HMMdat$timestep[n] > HMMdat$timestep[n-1]){
HMMdat$track[n] <- HMMdat$track[n-1] + 1
}
else {
HMMdat$track[n] <- HMMdat$track[n-1]
}
}
View(HMMdat)
# Remove tracks that are too short
table(HMMdat$track)
# Remove tracks that are too short
Ltrack <- table(HMMdat$track)
# Remove tracks that are too short
Ltrack <- data.frame(table(HMMdat$track))
View(Ltrack)
# Get track lengths and remove tracks that are too short
Ltrack <- data.frame(table(HMMdat$track))
Ltrack <- Ltrack[Ltrack$Freq > 10,]
HMMdat <- HMMdat[HMMdat$track %in% Ltrack$Var1]
# Get track lengths and remove tracks that are too short
Ltrack <- data.frame(table(HMMdat$track))
Ltrack <- Ltrack[Ltrack$Freq > 10,]
HMMdat <- HMMdat[HMMdat$track %in% Ltrack$Var1, ]
# Redefine trackno as animal ID for rerunning of prepData
HMMdat <- HMMdat[, c("x", "y", "Time", "track")]
colnames(HMMdat) <- c("x", "y", "Time", "ID")
# Re-run prepData for newly identified tracks
HMMdat2 <- prepData(HMMdat, type='UTM')
# Calculate Straightness Index (SI)
X <- split(HMMdat2, HMMdat2$ID)
for(d in 1:length(X)) {
track <- data.frame(X[d])
colnames(track) <- c("ID", "step", "angle", "x", "y", "Time")
track$SI <- NA
for (c in 6:(nrow(track)-1)){
dX <- track$x[c] - track$x[c-5]
dY <- track$y[c] - track$y[c-5]
TDist <- sum(track$step[(c-5):c])
LDist <- sqrt(dX^2 + dY^2)
#print(LDist / TDist)
track$SI[c] <- LDist / TDist
}
print(colnames(track))
if (d == 1) {
HMMdat2 <- track
}
else {
HMMdat2 <- rbind(HMMdat2, track)
}
}
HMMdat2 <- na.omit(HMMdat2)
# Construct HMM using depmixS4
HMMmod <- depmix(list(step ~ 1,SI ~ 1), data = HMMdat2, nstates = 2,
family = list(gaussian(), gaussian()))
# Fit HMM to data and calculate states+probabilities
fitHMMmod <- fit(HMMmod)
HMMdat2$state <- as.factor(viterbi(fitHMMmod)$state)
HMMdat2$prob1 <- viterbi(fitHMMmod)$S1
HMMdat2$prob2 <- viterbi(fitHMMmod)$S2
# Get mean values for states
mu <- ddply(HMMdat2, 'state', summarise,
step.mean = mean(step), SI.mean = mean(SI), angle.mean = mean(angle))
# Draw histograms
ggplot(HMMdat2, aes(x=step, color = state)) +
geom_histogram(aes(y=..density..), binwidth = (1/10),
colour = 1, fill = 'white') +
geom_density() +
#geom_vline(data=mu, aes(xintercept = step.mean, color=state)) +
ggtitle('Histogram of step lengths') +
theme(plot.title=element_text(hjust=0.5))
ggplot(HMMdat2, aes(x=SI, color = state)) +
geom_histogram(aes(y=..density..), binwidth = (1/10),
colour = 1, fill = 'white') +
geom_density()+
#geom_vline(data=mu, aes(xintercept = SI.mean, color=state)) +
ggtitle('Histogram of SI')+
theme(plot.title=element_text(hjust=0.5))
ggplot(HMMdat2, aes(x=angle, color = state)) +
geom_histogram(aes(y=..density..), binwidth = (1/10),
colour = 1, fill = 'white') +
geom_density()+
#geom_vline(data=mu, aes(xintercept = angle.mean, color=state)) +
ggtitle('Histogram of angle')+
theme(plot.title=element_text(hjust=0.5))
dT <- track$Time[c] - track$Time[c-5]
for(d in 1:length(X)) {
track <- data.frame(X[d])
colnames(track) <- c("ID", "step", "angle", "x", "y", "Time")
track$SI <- NA
for (c in 6:(nrow(track)-1)){
dX <- track$x[c] - track$x[c-5]
dY <- track$y[c] - track$y[c-5]
dT <- track$Time[c] - track$Time[c-5]
TDist <- sum(track$step[(c-5):c])
LDist <- sqrt(dX^2 + dY^2)
#print(LDist / TDist)
track$SI[c] <- LDist / TDist
}
print(colnames(track))
if (d == 1) {
HMMdat2 <- track
}
else {
HMMdat2 <- rbind(HMMdat2, track)
}
}
track$Time[c-5]
track$Time[c]
track$Time[c]
track$Time[c-4]
library(moveHMM)
library(ggplot2)
library(tidyr)
library(plyr)
library(dplyr)
library(depmixS4)
library(crawl)
# Read data
fish <- read.csv("C:\\Users\\jelings\\OneDrive - UGent\\Documenten\\INBO\\Altusreid\\Filtered_Fish_Datasets_HPE_RMSE_VELOCITY\\filtered_data_1_grayling_46909_HPE_RMSE_Vel.csv")
fish$Time <- as.POSIXct(fish$Time)
# Construct movement model and regularize data
fishreg <- crwMLE(data = fish, coord = c('UTM.x', 'UTM.y'), Time.name = c("Time") , time.scale = 'secs')
fishreg <- crwPredict(object.crwFit = fishreg,
predTime = seq.POSIXt(from = min(fish$Time), to = max(fish$Time), by = '5 secs'),
return.type = 'minimal')
# Isolate predicted positions
fishpred <- fishreg[fishreg$locType == 'p', ]
# Pred data for HMM(= calculate steps and TAs)
HMMdat <- prepData(fishpred[c('Time', 'mu.x', 'mu.y')], coordNames = c('mu.x', 'mu.y'), type = 'UTM')
#plot(HMMdat, compact=T)
# Calculate dStepLength and remove when dStep approaches 0 (indicating regularization in detection gaps)
# Break arbitrarily chosen based on rounding errors
HMMdat$dStep <- HMMdat$step - lag(HMMdat$step)
HMMdat <- HMMdat[(HMMdat$dStep > 3.172941e-08) | (HMMdat$dStep < -3.172941e-08), ]
HMMdat <- drop_na(HMMdat)
rownames(HMMdat) <- NULL
# Calculate timesteps to identify where detections are removed (i.e. tracks break)
# Add in timestep for first value to run for-loop later
HMMdat$timestep <- HMMdat$Time - lag(HMMdat$Time)
HMMdat$timestep[1] <- as.difftime(5, format = '%S', units = 'secs')
# Construct trackno column and initialize with Track 1
HMMdat$track <- NA
HMMdat$track[1] <- 1
# Run for-loop to count tracks
for (n in 2:nrow(HMMdat)){
if (HMMdat$timestep[n] > HMMdat$timestep[n-1]){
HMMdat$track[n] <- HMMdat$track[n-1] + 1
}
else {
HMMdat$track[n] <- HMMdat$track[n-1]
}
}
# Get track lengths and remove tracks that are too short
Ltrack <- data.frame(table(HMMdat$track))
Ltrack <- Ltrack[Ltrack$Freq > 10,]
HMMdat <- HMMdat[HMMdat$track %in% Ltrack$Var1, ]
# Redefine trackno as animal ID for rerunning of prepData
HMMdat <- HMMdat[, c("x", "y", "Time", "track")]
colnames(HMMdat) <- c("x", "y", "Time", "ID")
# Re-run prepData for newly identified tracks
HMMdat2 <- prepData(HMMdat, type='UTM')
#plot(HMMdat2, compact = T)
# Calculate Straightness Index (SI) over 30s
X <- split(HMMdat2, HMMdat2$ID)
for(d in 1:length(X)) {
track <- data.frame(X[d])
colnames(track) <- c("ID", "step", "angle", "x", "y", "Time")
track$SI <- NA
for (c in 5:(nrow(track)-1)){
dX <- track$x[c] - track$x[c-4]
dY <- track$y[c] - track$y[c-4]
dT <- track$Time[c] - track$Time[c-4]
TDist <- sum(track$step[(c-4):c])
LDist <- sqrt(dX^2 + dY^2)
#print(LDist / TDist)
track$SI[c] <- LDist / TDist
}
print(colnames(track))
if (d == 1) {
HMMdat2 <- track
}
else {
HMMdat2 <- rbind(HMMdat2, track)
}
}
HMMdat2 <- na.omit(HMMdat2)
# Construct HMM using depmixS4
HMMmod <- depmix(list(step ~ 1,SI ~ 1), data = HMMdat2, nstates = 2,
family = list(gaussian(), gaussian()))
# Fit HMM to data and calculate states+probabilities
fitHMMmod <- fit(HMMmod)
HMMdat2$state <- as.factor(viterbi(fitHMMmod)$state)
HMMdat2$prob1 <- viterbi(fitHMMmod)$S1
HMMdat2$prob2 <- viterbi(fitHMMmod)$S2
library(moveHMM)
library(ggplot2)
library(tidyr)
library(plyr)
library(dplyr)
library(depmixS4)
library(crawl)
# Draw histograms
ggplot(HMMdat2, aes(x=step, color = state)) +
geom_histogram(aes(y=..density..), binwidth = (1/10),
colour = 1, fill = 'white') +
geom_density() +
#geom_vline(data=mu, aes(xintercept = step.mean, color=state)) +
ggtitle('Histogram of step lengths') +
theme(plot.title=element_text(hjust=0.5))
ggplot(HMMdat2, aes(x=SI, color = state)) +
geom_histogram(aes(y=..density..), binwidth = (1/10),
colour = 1, fill = 'white') +
geom_density()+
#geom_vline(data=mu, aes(xintercept = SI.mean, color=state)) +
ggtitle('Histogram of SI')+
theme(plot.title=element_text(hjust=0.5))
ggplot(HMMdat2, aes(x=angle, color = state)) +
geom_histogram(aes(y=..density..), binwidth = (1/10),
colour = 1, fill = 'white') +
geom_density()+
#geom_vline(data=mu, aes(xintercept = angle.mean, color=state)) +
ggtitle('Histogram of angle')+
theme(plot.title=element_text(hjust=0.5))
View(track)
View(Ltrack)
# Get track lengths and remove tracks that are too short
Ltrack <- data.frame(table(HMMdat$track))
HMMdat$track <- NA
HMMdat$track[1] <- 1
# Run for-loop to count tracks
for (n in 2:nrow(HMMdat)){
if (HMMdat$timestep[n] > HMMdat$timestep[n-1]){
HMMdat$track[n] <- HMMdat$track[n-1] + 1
}
else {
HMMdat$track[n] <- HMMdat$track[n-1]
}
}
HMMdat <- prepData(fishpred[c('Time', 'mu.x', 'mu.y')], coordNames = c('mu.x', 'mu.y'), type = 'UTM')
#plot(HMMdat, compact=T)
# Calculate dStepLength and remove when dStep approaches 0 (indicating regularization in detection gaps)
# Break arbitrarily chosen based on rounding errors
HMMdat$dStep <- HMMdat$step - lag(HMMdat$step)
HMMdat <- HMMdat[(HMMdat$dStep > 3.172941e-08) | (HMMdat$dStep < -3.172941e-08), ]
HMMdat <- drop_na(HMMdat)
rownames(HMMdat) <- NULL
# Calculate timesteps to identify where detections are removed (i.e. tracks break)
# Add in timestep for first value to run for-loop later
HMMdat$timestep <- HMMdat$Time - lag(HMMdat$Time)
HMMdat$timestep[1] <- as.difftime(5, format = '%S', units = 'secs')
# Construct trackno column and initialize with Track 1
HMMdat$track <- NA
HMMdat$track[1] <- 1
# Run for-loop to count tracks
for (n in 2:nrow(HMMdat)){
if (HMMdat$timestep[n] > HMMdat$timestep[n-1]){
HMMdat$track[n] <- HMMdat$track[n-1] + 1
}
else {
HMMdat$track[n] <- HMMdat$track[n-1]
}
}
# Get track lengths and remove tracks that are too short
Ltrack <- data.frame(table(HMMdat$track))
Ltrack <- Ltrack[Ltrack$Freq > 10,]
HMMdat <- HMMdat[HMMdat$track %in% Ltrack$Var1, ]
# Redefine trackno as animal ID for rerunning of prepData
HMMdat <- HMMdat[, c("x", "y", "Time", "track")]
colnames(HMMdat) <- c("x", "y", "Time", "ID")
View(HMMdat2)
View(HMMdat2)
HMMdat2[, c('ID', 'step', 'angle', 'x', 'y', 'Time')
]
plot(HMMdat2)
View(HMMdat2)
# Re-run prepData for newly identified tracks
HMMdat2 <- prepData(HMMdat, type='UTM')
plot(HMMdat2, compact = T)
stepmean <- c(1, 4)
stepsd <- c(0.1, 1)
stepPar0 <- c(stepmean, stepsd)
m <- fitHMM(HMMdat2[, c('ID', 'step', 'angle', 'x', 'y', 'Time')],
stepPar0 = stepPar0, angleDist = 'none')
m <- fitHMM(HMMdat2[, c('ID', 'step', 'angle', 'x', 'y', 'Time')],
nbStates = 2, stepPar0 = stepPar0, angleDist = 'none')
m
plot(m)
X <- split(HMMdat2, HMMdat2$ID)
for(d in 1:length(X)) {
track <- data.frame(X[d])
colnames(track) <- c("ID", "step", "angle", "x", "y", "Time")
track$SI <- NA
for (c in 5:(nrow(track)-1)){
dX <- track$x[c] - track$x[c-4]
dY <- track$y[c] - track$y[c-4]
dT <- track$Time[c] - track$Time[c-4]
TDist <- sum(track$step[(c-4):c])
LDist <- sqrt(dX^2 + dY^2)
#print(LDist / TDist)
track$SI[c] <- LDist / TDist
}
#print(colnames(track))
if (d == 1) {
HMMdat2 <- track
}
else {
HMMdat2 <- rbind(HMMdat2, track)
}
}
HMMdat2 <- na.omit(HMMdat2)
# Construct HMM using depmixS4
HMMmod <- depmix(list(step ~ 1,SI ~ 1), data = HMMdat2, nstates = 2,
family = list(gaussian(), gaussian()))
# Fit HMM to data and calculate states+probabilities
fitHMMmod <- fit(HMMmod)
HMMdat2$state <- as.factor(viterbi(fitHMMmod)$state)
HMMdat2$prob1 <- viterbi(fitHMMmod)$S1
HMMdat2$prob2 <- viterbi(fitHMMmod)$S2
# Get mean values for states
mu <- ddply(HMMdat2, 'state', summarise,
step.mean = mean(step), SI.mean = mean(SI), angle.mean = mean(angle))
mu
moveHMMdat <- prepData(HMMdat, type='UTM')
stepmean <- c(0.5, 1)
stepsd <- c(0.1, 1)
stepPar0 <- c(stepmean, stepsd)
m <- fitHMM(HMMdat2[, c('ID', 'step', 'angle', 'x', 'y', 'Time')],
nbStates = 2, stepPar0 = stepPar0, angleDist = 'none')
View(HMMdat)
plot(HMMdat, compact=T)
fish <- read.csv("C:\\Users\\jelings\\OneDrive - UGent\\Documenten\\INBO\\Altusreid\\Filtered_Fish_Datasets_HPE_RMSE_VELOCITY\\filtered_data_1_grayling_46909_HPE_RMSE_Vel.csv")
fish$Time <- as.POSIXct(fish$Time)
# Construct movement model and regularize data
fishreg <- crwMLE(data = fish, coord = c('UTM.x', 'UTM.y'), Time.name = c("Time") , time.scale = 'secs')
fishreg <- crwPredict(object.crwFit = fishreg,
predTime = seq.POSIXt(from = min(fish$Time), to = max(fish$Time), by = '5 secs'),
return.type = 'minimal')
# Isolate predicted positions
fishpred <- fishreg[fishreg$locType == 'p', ]
# Pred data for HMM(= calculate steps and TAs)
HMMdat <- prepData(fishpred[c('Time', 'mu.x', 'mu.y')], coordNames = c('mu.x', 'mu.y'), type = 'UTM')
plot(HMMdat, compact=T)
# Calculate dStepLength and remove when dStep approaches 0 (indicating regularization in detection gaps)
# Breakpoint arbitrarily chosen based on rounding errors
HMMdat$dStep <- HMMdat$step - lag(HMMdat$step)
HMMdat <- HMMdat[(HMMdat$dStep > 3.172941e-08) | (HMMdat$dStep < -3.172941e-08), ]
HMMdat <- drop_na(HMMdat)
rownames(HMMdat) <- NULL
# Calculate timesteps to identify where detections are removed (i.e. tracks break)
# Add in timestep for first value to run for-loop later
HMMdat$timestep <- HMMdat$Time - lag(HMMdat$Time)
HMMdat$timestep[1] <- as.difftime(5, format = '%S', units = 'secs')
# Construct trackno column and initialize with Track 1
HMMdat$track <- NA
HMMdat$track[1] <- 1
# Run for-loop to count tracks
for (n in 2:nrow(HMMdat)){
if (HMMdat$timestep[n] > HMMdat$timestep[n-1]){
HMMdat$track[n] <- HMMdat$track[n-1] + 1
}
else {
HMMdat$track[n] <- HMMdat$track[n-1]
}
}
# Get track lengths and remove tracks that are too short
Ltrack <- data.frame(table(HMMdat$track))
Ltrack <- Ltrack[Ltrack$Freq > 10,]
HMMdat <- HMMdat[HMMdat$track %in% Ltrack$Var1, ]
# Redefine trackno as animal ID for rerunning of prepData
HMMdat <- HMMdat[, c("x", "y", "Time", "track")]
colnames(HMMdat) <- c("x", "y", "Time", "ID")
moveHMMdat <- prepData(HMMdat, type='UTM')
# Re-run prepData for newly identified tracks
HMMdat2 <- prepData(HMMdat, type='UTM')
# Calculate Straightness Index (SI) over 30s
X <- split(HMMdat2, HMMdat2$ID)
for(d in 1:length(X)) {
track <- data.frame(X[d])
colnames(track) <- c("ID", "step", "angle", "x", "y", "Time")
track$SI <- NA
for (c in 5:(nrow(track)-1)){
dX <- track$x[c] - track$x[c-4]
dY <- track$y[c] - track$y[c-4]
dT <- track$Time[c] - track$Time[c-4]
TDist <- sum(track$step[(c-4):c])
LDist <- sqrt(dX^2 + dY^2)
#print(LDist / TDist)
track$SI[c] <- LDist / TDist
}
#print(colnames(track))
if (d == 1) {
HMMdat2 <- track
}
else {
HMMdat2 <- rbind(HMMdat2, track)
}
}
HMMdat2 <- na.omit(HMMdat2)
stepmean <- c(0.5, 1)
stepsd <- c(0.1, 1)
stepPar0 <- c(stepmean, stepsd)
m <- fitHMM(HMMdat2[, c('ID', 'step', 'angle', 'x', 'y', 'Time')],
nbStates = 2, stepPar0 = stepPar0, angleDist = 'none')
View(moveHMMdat)
m <- fitHMM(moveHMMdat,
nbStates = 2, stepPar0 = stepPar0, angleDist = 'none')
m
mu
# Construct HMM using depmixS4
HMMmod <- depmix(step ~ 1, data = HMMdat2, nstates = 2)
# Fit HMM to data and calculate states+probabilities
fitHMMmod <- fit(HMMmod)
HMMdat2$state <- as.factor(viterbi(fitHMMmod)$state)
HMMdat2$prob1 <- viterbi(fitHMMmod)$S1
HMMdat2$prob2 <- viterbi(fitHMMmod)$S2
fitHMMmod
summary(ffitHMMmod)
summary(fitHMMmod)
AIC(m)
BIC(m)
library(momentuHMM)
?crawlWrap
library(moveHMM)
library(EnvStats)
library(ggplot2)
library(tidyr)
library(plyr)
library(ddply)
library(dplyr)
library(depmixS4)
library(crawl)
library(circular)
range(fishpred$Time)
